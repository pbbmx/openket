from sympy import Symbol, symbols, expand, I, N
from sympy.core.cache import clear_cache
from pylab import conjugate
import shutil
import re as regex

from .metrics import dag,sub_qexpr,op2dict

__all__ = ['init_state','sym2num','build_ode','gsl_main']


def init_state(rho, rho0, basis, dic):
    """
    This function produces an initial condition in the form of a list (ordered in accordance to the variables :math:`y_i`),
    given the initial condition as a sum of outer products ``rho0``.
    The basis ``basis`` has to be given as a list of :obj:`Ket` objects, as well as the dictionary ``dic`` generated by :obj:`openket.build_ode <openket.core.metrics.build_ode>`.
    Also, the density operator ``rho`` used in :obj:`openket.build_ode <openket.core.metrics.build_ode>` must be the same.
    
    :param rho: Operator involved. Corresponds to the density operator for which we want to calculte the evolution.
    :type rho: :obj:`Operator`
    :param rho0: Total expression of outer products as sum of :obj:`Ket`:obj:`Bra` objects.
    :type rho0: openket expression
    :param basis: List of :obj:`Ket` objects containing all the elements of the basis.
    :type basis: list
    :param dic: Dictionary object given by the :obj:`openket.op2dict <openket.core.metrics.op2dict>` function.
    :type dic: dict
    :return: Retuns a :math:`2n^2` length list with the initial conditions values, which every two places correspond to a single complex number. :math:`n` is the basis dimension.
    :rtype: list

    Example
    ^^^^^^^^^

    Example with coherent states (quantum optics):
    
        .. code-block:: python
        
            >>> # Define parameters and basis
            >>> n = 5  # Truncation level
            >>> alpha = 1  # Coherent state amplitude
            >>> basis = [Ket(i,"field") for i in range(n)]  # Fock basis
            
            # Create coherent state (initial condition)
            >>> state_alpha = 0
            >>> for i in range(n):
                    state_alpha = state_alpha + ((alpha**i) / math.sqrt(math.factorial(i))) * Ket(i,"field")
            >>> state_alpha = np.exp(-(np.abs(alpha)**2)/2) * state_alpha
            >>> rho0 = state_alpha * dag(state_alpha)  # Density matrix
            
            # Generate initial conditions for ODE solver input
            >>> initcons = init_state(
                    rho=Operator("R"), 
                    rho0=rho0, 
                    basis=basis, 
                    dic=dic
                )
    
            # initcons now contains the properly ordered initial values for all math:`y_i` variables
            >>> print(initcons)
            [0.367879441171442, 0, 0.367879441171442, 0, 0.260130047511444, 0, 0.150186152955043, 0, 0.0750930764775213, 0, 0.367879441171442, 0, 0.367879441171442, 0, 0.260130047511444, 0, 0.150186152955043, 0, 0.0750930764775213, 0, 0.260130047511444, 0, 0.260130047511444, 0, 0.183939720585721, 0, 0.106197647194831, 0, 0.0530988235974153, 0, 0.150186152955043, 0, 0.150186152955043, 0, 0.106197647194831, 0, 0.0613132401952404, 0, 0.0306566200976202, 0, 0.0750930764775213, 0, 0.0750930764775213, 0, 0.0530988235974153, 0, 0.0306566200976202, 0, 0.0153283100488101, 0]
    
    Note: This example shows how to prepare initial conditions for a coherent state in quantum optics simulations.
    The resulting :code:`initcons` can be used directly with :obj:`scipy.integrate.odeint` or similar ODE solvers.
    """
    n=len(basis)
    ini = [0]*(2*n**2)
    # ini = [0]*(n*(n+1))
    tempdic = {}
    for bra in basis:
        bra = dag(bra)
        for ket in basis:
            # if basis.index(i) <= basis.index(j):
                tempvar = sub_qexpr(bra*rho*ket,dic)
                tempdic[expand( (tempvar + conjugate(tempvar))/2. )] = expand((bra*rho0*ket + dag(ket)*rho0*dag(bra))/2.) #parte real
                tempdic[expand( (tempvar - conjugate(tempvar))/(2.*I) )] = expand((bra*rho0*ket - dag(ket)*rho0*dag(bra))/(2.*I)) #parte imaginaria
    for i in tempdic.keys():
        ini[int(str(i).partition('y')[-1])] = tempdic[i]
    return ini

def sym2num(sol, symbexpr, symbmap=None):
    """This function converts symbolic variable expressions into their corresponding time evolution values obtained from an ODE solution.
    It substitutes each symbolic variable in the input expression with its time series data from the ODE solution.
    The function handles both single variables and complex expressions containing multiple variables. For each time point in the solution,
    it substitutes the variable values and evaluates the expression.

    :param sol: The solution ndarray returned by :obj:`scipy.integrate.odeint`.
            Each column represents the time evolution of a variable (:math:`y0`, :math:`y1`, etc. or defined by ``symbmap``),
            with rows corresponding to different time points.
    :type sol: numpy.ndarray
    :param symbexpr: Symbolic expression of the form :math:`y^k`, given by :obj:`openket.sub_qexpr <openket.core.metrics.sub_qexpr>`.
    :type symbexpr: sympy.expr
    :param symbmap: Optional dict mapping symbols to column indices (default: assume symbols are y0, y1, ...)
    :type symbmap: dict
    :return: A list containing the numerical evaluated expression values at each time point.
            The length matches the number of time points in ``sol``.
    :rtype: list
    """
    temp={}; L = []
    if symbmap is None:
        symbmap = {s: int(str(s).partition('y')[-1]) for s in symbexpr.atoms(Symbol)}
    for count in range(len(sol)):
        for symbol in symbexpr.atoms(Symbol):
            temp[symbol] = sol[count][symbmap[symbol]]
        L.append(complex(N(symbexpr.subs(temp))))
    return L

def build_ode(rho, rdot, basis, y0=None, t=None, args=(), options={}, filetype=None, filename="func", dictname="dic"):
    """
    The main purpose for this function is to study time evolution of an operator, with an expression
    for its time derivative, both given in a specified basis.
    This function creates a file called ``filename`` which defines a function
    in the sintaxis needed to feed `Scipy's ODE solver odeint <https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.odeint.html>`_
    or `GSL's ODE solver gsl_odeiv2.h <https://www.gnu.org/software/gsl/doc/html/ode-initval.html>`_,
    or just applies the :obj:`scipy.integrate.odeint` function with the given parameters.

    :param rho: Operator involved. The function turns it in terms of the basis ``basis``.
    :type rho: :obj:`Operator`
    :param rdot: Operator that expresses change over the time, usually the comm :math:`[H,\\rho]` where :math:`H` is the Hamiltonian of the system
                and :math:`\\rho` the density operator.
    :type rdot: :obj:`Operator`
    :param basis: List of :obj:`Ket` objects containing all the elements of the basis.
    :type basis: array
    :param y0: Initial condition on :math:`y`, necessary for the solution only if :code:`file=None`.
    :type y0: array, optional
    :param t: A sequence of time points for which to solve for :math:`y`, necessary if :code:`file=None`.
    :type t: array, optional
    :param args: Extra arguments to pass to :obj:`scipy.integrate.odeint` function (see `documentation <https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.odeint.html>`_).
                in case :code:`filetype=None`.
    :type args: tuple, optional
    :param options: Parameters to pass to :obj:`scipy.integrate.odeint` function (see `documentation <https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.odeint.html>`_).
                in case :code:`filetype=None`.
    :type options: dict, optional
    :param filetype:
        * :code:`filetype=None`: the function runs :obj:`scipy.integrate.odeint` with the given parameters.
        * :code:`filetype="GSL"`: creates a C syntax file to :obj:`gsl_odeiv2.h` solver.
        * :code:`filetype="Scipy"`: creates a Python syntax file to :obj:`scipy.integrate.odeint` solver.
    :type filetype: string, optional
    :param filename: The name of the out file with the function. File extension must be inclided.
    :type filename: string, optional
    :param dictname: The name of the dictionay file.
    :type dictname: string, optional
    :return: If :code:`filetype=None` returns an array with the ODE solution values; other case returns a file with a function written in the sintaxis defined.
            Also returns the dictionary with the operator ``rho`` elements expressed in the basis ``basis``, and the different expressions
            of time evolution for every matrix element substituting them for symbolic variables.
            Finally it writes the function :math:`f` into a file, where the ODE has the form :math:`\\frac{dy}{dt} = f(y,t)`;
            :math:`y` should be understood as a vector, which is defined entry-like as a list, and :math:`t` is the time variable.
            :math:`f` returns also a list, containig the expressions of the derivatives of each entry
            of :math:`y` as entries of another list. 
            :obj:`scipy.integrate.odeint` and :obj:`gsl_odeiv2.h` understand this as a collection of coupled ODE to be solved, specifying
            an initial condition and the time step.
    :rtype: array or file

    Example
    ^^^^^^^^^

    Suppose we want to see the time evolution of the Hamiltonian :math:`\\hat{H} = \\hbar (\\Omega |0 \\rangle \\langle 1| + \\Omega^* |1 \\rangle \\langle 0|)`
    (Two-Level Semiclassical Atom). We assume :math:`\\Omega = 1` for simplicity.
    Following is the script which numerically solves the time evolution of the system described.

        .. code-block:: python
        
            >>> import matplotlib.pyplot as plt
            >>> from numpy import linspace
            >>> from scipy.integrate import odeint

            >>> basis = [Ket(0), Ket(1)]
            >>> rho = Operator("R")
            >>> rdot = -I*comm(H, rho)
            >>> H = Ket(0)*Bra(1) + Ket(1)*Bra(0)
            
            >>> y0 = [1,0, 0,0, 0,0, 0,0] #[1+i0, 0+i0, 0+i0, 0+i0]
            >>> t = linspace(0,10,1000)

            >>> solution = build_ode(rho=rho, rdot=rdot, basis=basis, y0=y0, t=t, file=None)
            >>> plt.plot(t, solution[:,3])
            >>> plt.show()

    Note that the initial condition is given as an array, where the position indicates the bracket term that one wishes
    to give as the initial condition (the dic tells you which is which). As we are working with complex numbers, we represent one number
    with two positions in the list.
    Finally, the command :code:`solution[:,3]` partitions the total solution and only keeps the third entry 
    (:code:`y[3]` corresponding to :math:`\\langle 1| \\rho |1 \\rangle`) in all the lists within `solution`.
    The graph we obtain is the following.

    .. figure:: two_level_system.png
        :scale: 85 %

        Time evolution for :math:`\\langle 1| \\rho |1 \\rangle` with the initial condition :math:`\\rho_{t=0} = |0 \\rangle \\langle 0|`
    
    """
    
    #GSL ODE solver (C language)
    if filetype == "GSL":  
        #se crea el diccionario para la base b y el operador R
        D = op2dict(rho, basis)
        f = open(filename, 'w')
        f.write('#include <stdio.h>\n')
        f.write('#include <math.h>\n')
        f.write('#include <complex.h>\n') 
        f.write('#include <gsl/gsl_errno.h>\n')
        f.write('#include <gsl/gsl_matrix.h>\n')
        f.write('#include <gsl/gsl_odeiv2.h>\n\n')
        f.write('int func (double t, const double y[], double f[], void *params) {\n')

        # crea la lista de valores reales e imaginarios W = [Re1,Im1,...,...,Ren*n,Imn*n]
        W = []
        n = len(basis)
        for k in range( n*n ):
            W.append(symbols('Re%d' %k, real=True, each_char=False))
            W.append(symbols('Im%d' %k, real=True, each_char=False))

        # crea una lista con los strings L = [y[0],y[1],...,y[2*n*n]]
        L = ['y[' + '%d' %i + ']' for i in range(2*n*n)]

        # crea el diccionario lista = {'Re1': y[0], ... ,'Imn*n': y[2n*n]}
        lista={}
        for mi in range(2*n*n): lista[W[mi]]=Symbol(L[mi])

        # escribe el sistema de ecuaciones para encontrar los valores a,b de los coeficientes a+ib
        for i,ele in enumerate(basis):
            bra = dag(ele)
            # print (i,"/",len(basis))
            clear_cache()
            for j,ket in enumerate(basis):
                k = 2*(i*n + j)
                z = bra*rdot*ket
                zz = sub_qexpr(z, D)
                re = expand((zz+conjugate(zz))/2.0,complex=True)
                im = expand((zz-conjugate(zz))/(2.0*I),complex=True)
                for var_subs in re.atoms(Symbol):
                    if var_subs in lista:
                        re = re.subs(var_subs,lista[var_subs])
                f.write('    ' + 'f[%d] = ' %k + str(re) + ';\n')
                for var_subs in im.atoms(Symbol):
                    if var_subs in lista:
                        im = im.subs(var_subs,lista[var_subs])
                k = k + 1
                f.write('    ' + 'f[%d] = ' %k + str(im) + ';\n')
        f.write('    ' + 'return GSL_SUCCESS;\n')
        f.write('}\n\n')

        dim = len(L)
        f.write(f'int dim = {str(dim)};\n')

        # crea el diccionario que relaciona '<i|R|j>' con las y[i]
        f = open(dictname+'.py', 'w')
        f.write("from sympy import var, I\n")
        f.write(f'{dictname}='+'{')
        for bra in basis:
            bra = dag(bra)
            for ket in basis:
                temp = bra*rho*ket
                temp = sub_qexpr(temp, D)
                for var_subs in temp.atoms(Symbol):
                    etiqueta=regex.search(r"\[(.*)\]",str(lista[var_subs]))
                    temp = temp.subs(var_subs,Symbol("var('y"+etiqueta.groups()[0]+"',real=True)"))
                f.write(f"'{str(bra*rho*ket)}': {str(temp)},\n")
        f.write('}')
        f.close()
        
        # if options.get('gsl_main', False):
        #     h0 = options.get('h0', 1e-6)
        #     atol = options.get('atol', 1e-6)
        #     rtol = options.get('rtol', 0.0)
        #     filename1 = options.get('new_filename', "func_main.c")
        #     format = options.get('format', "CSV")
        #     gsl_method = options.get('gsl_method', "gsl_odeiv2_step_rkf45")
        #     symbexpr = options.get('symbexpr', "default")
            
        #     lt = len(t) if t is not None else 0
        #     y0 = str([float(y) for y in y0])[1:-1] if y0 is not None else ""
        #     t = str(t.tolist())[1:-1] if t is not None else ""

        #     _gsl_maincode(y0, t, lt, h0, atol, rtol, filename, filename1, format, gsl_method, symbexpr)

    #Scipy's ODE solver (python language)
    elif filetype == "Scipy":
        D = op2dict(rho, basis)
        with open(filename, 'w') as f:
            f.write('from sympy import var, I\n')
            f.write('from numpy import sqrt\n')
            f.write('def f(y, t):\n')
            
            # crea la lista de valores reales e imaginarios W = [Re1,Im1,...,...,Ren*n,Imn*n]
            W = []
            n = len(basis)
            for k in range(n*n):
                W.append(symbols('Re%d' %k, real=True, each_char=False))
                W.append(symbols('Im%d' %k, real=True, each_char=False))

            # crea una lista con los strings L = [y[0],y[1],...,y[2*n*n]]
            L = ['y[' + '%d' %i + ']' for i in range(2*n*n)]

            # crea el diccionario lista = {'Re1': y[0], ... ,'Imn*n': y[2n*n]}
            lista={}
            for mi in range(2*n*n): lista[W[mi]]=Symbol(L[mi])
            
            # escribe el sistema de ecuaciones para encontrar los valores a,b de los coeficientes a+ib
            f.write('    ' + 'return [')    
            for i,ele in enumerate(basis):
                bra = dag(ele)
                # print (i,"/",len(basis))
                clear_cache()
                for j,ket in enumerate(basis):
                    z = bra*rdot*ket
                    zz = sub_qexpr(z, D)
                    re = expand((zz+conjugate(zz))/2.0,complex=True)
                    im = expand((zz-conjugate(zz))/(2.0*I),complex=True)
                    for var_subs in re.atoms(Symbol):
                        if var_subs in lista:
                            re = re.subs(var_subs,lista[var_subs])
                    f.write(str(re)+',\n')
                    for var_subs in im.atoms(Symbol):
                        if var_subs in lista:
                            im = im.subs(var_subs,lista[var_subs])
                    f.write(str(im))
                    if basis.index(ele)*basis.index(ket)==(len(basis)-1)**2:
                        f.write(']\n\n')
                    else:
                        f.write(',\n')

            # crea el diccionario que relaciona '<i|R|j>' con las y[i]
            f.write(dictname + '={')
            for bra in basis:
                bra = dag(bra)
                for ket in basis:
                    temp = bra*rho*ket
                    temp = sub_qexpr(temp, D)
                    for var_subs in temp.atoms(Symbol):
                        etiqueta = regex.search(r"\[(.*)\]",str(lista[var_subs]))
                        temp = temp.subs(var_subs,Symbol("var('y"+etiqueta.groups()[0]+"',real=True)"))
                    f.write("'" + str(bra*rho*ket) + "'" + ':' + str(temp) + ',\n')
            f.write( '}')

    #Scipy's ODE solver (automatic)
    elif filetype == None:
        D = op2dict(rho, basis)
        script = 'from scipy.integrate import odeint\n'
        script += 'from sympy import var, I\n'
        script += 'from numpy import sqrt\n'
        script += 'def f(y, t):\n'
        
        # crea la lista de valores reales e imaginarios W = [Re1,Im1,...,...,Ren*n,Imn*n]
        W = []
        n = len(basis)
        for k in range(n*n):
            W.append(symbols('Re%d' %k, real=True, each_char=False))
            W.append(symbols('Im%d' %k, real=True, each_char=False))

        # crea una lista con los strings L = [y[0],y[1],...,y[2*n*n]]
        L = ['y[' + '%d' %i + ']' for i in range(2*n*n)]

        # crea el diccionario lista = {'Re1': y[0], ... ,'Imn*n': y[2n*n]}
        lista={}
        for mi in range(2*n*n): lista[W[mi]]=Symbol(L[mi])
        
        # escribe el sistema de ecuaciones para encontrar los valores a,b de los coeficientes a+ib
        script += '    ' + 'return ['
        for i,ele in enumerate(basis):
            bra = dag(ele)
            clear_cache()
            for j,ket in enumerate(basis):
                z = bra*rdot*ket
                zz = sub_qexpr(z, D)
                re = expand((zz+conjugate(zz))/2.0,complex=True)
                im = expand((zz-conjugate(zz))/(2.0*I),complex=True)
                for var_subs in re.atoms(Symbol):
                    if var_subs in lista:
                        re = re.subs(var_subs,lista[var_subs])
                script += str(re)+',\n'
                for var_subs in im.atoms(Symbol):
                    if var_subs in lista:
                        im = im.subs(var_subs,lista[var_subs])
                script += str(im)
                if basis.index(ele)*basis.index(ket)==(len(basis)-1)**2:
                    script += ']\n\n'
                else:
                    script += ',\n'

        # crea el diccionario que relaciona '<i|R|j>' con las y[i]
        script += dictname + '={'
        for bra in basis:
            bra = dag(bra)
            for ket in basis:
                temp = bra*rho*ket
                temp = sub_qexpr(temp, D)
                for var_subs in temp.atoms(Symbol):
                    etiqueta = regex.search(r"\[(.*)\]",str(lista[var_subs]))
                    temp = temp.subs(var_subs,Symbol("var('y"+etiqueta.groups()[0]+"',real=True)"))
                script += "'" + str(bra*rho*ket) + "'" + ':' + str(temp) + ',\n'
        script += '}\n\n'
        script += f'y0 = {str(y0)}\n'
        script += f't = {t.tolist()}\n'
        script += f"solution = odeint(\
                            func=f,\
                            y0=y0,\
                            t=t,\
                            args={args},\
                            Dfun={options.get('Dfun', None)},\
                            col_deriv={options.get('col_deriv', 0)},\
                            full_output={options.get('full_output', 0)},\
                            ml={options.get('ml', None)},\
                            mu={options.get('mu', None)},\
                            rtol={options.get('rtol', None)},\
                            atol={options.get('atol', None)},\
                            tcrit={options.get('tcrit', None)},\
                            h0={options.get('h0', 0.0)},\
                            hmax={options.get('hmax', 0.0)},\
                            hmin={options.get('hmin', 0.0)},\
                            ixpr={options.get('ixpr', 0)},\
                            mxstep={options.get('mxstep', 0)},\
                            mxhnil={options.get('mxhnil', 0)},\
                            mxordn={options.get('mxordn', 12)},\
                            mxords={options.get('mxords', 5)},\
                            printmessg={options.get('printmessg', 0)},\
                            tfirst={options.get('tfirst', False)}\
                        )"
        context = {}
        exec(script, context)
        return context['solution']

def gsl_main(odefile, y0, tspan, step, symbexprs="default", options={}, outfile="funcMain.c"):
    """This function takes the file ``odefile`` with the function that the user want to solve
    (generated by :obj:`openket.build_ode <openket.core.evolution.build_ode>`) and add the main
    function in C code needed to solve the ODE system in the
    `GSL's ODE solver gsl_odeiv2.h <https://www.gnu.org/software/gsl/doc/html/ode-initval.html>`_.
    This function need the inicial conditions ``y0`` in a list and a tuple with the values of the
    initial time and final time ``tspan``.

    :param odefile: Path to the file containing the ODE system definition generated by :obj:`openket.build_ode <openket.core.evolution.build_ode>`
                    function.
    :type odefile: string
    :param y0: Initial conditions for the ODE system.
    :type y0: list
    :param tspan: Time domain specification (``t0``, ``t1``). Solve from ``t0`` to ``t1``.
    :type tspan: tuple
    :param step: Step size.
    :type step: int
    :param symbexprs: List of symbolic openket expressions (available if :code:`options.output_format = "hdf5"`).
                Each element of the list represents an observable that you want to save in the output data.
                This observable must be written in the syntaxis of a :obj:`sub_qexpr` output expression.
                Remember that :obj:`sub_qexpr` use the dictionary to translate from Bras and Kets to variables.
    :type symbexprs: list, optional
    :param options:
                * h0: (:code:`hstart` in GSL) Value for the initial step in the ODE solver, defaults to 1e-6.
                * atol: (:code:`epsabs` in GSL) Absolute error tolerance, defaults to 1e-6.
                * rtol: (:code:`epsrel` in GSL) Relative error tolerance, defaults to 0.0.
                * output_format: :code:`output_format="csv"` if the output format is going to be CSV, or :code:`output_format="hdf5"` if is going to be HDF5. Defualts to :code:`format="csv"`.
                * solver_method: GSL solver method 'rkf45', 'rk8pd', 'rk4', 'bsimp' (stiff), etc. (see `documentation <https://www.gnu.org/software/gsl/doc/html/ode-initval.html#stepping-functions>`_)
    :type options: dict, optional
    :param outfile: Name for the output file with the main function added, defaults to "funcMain.c".
    :type outfile: str, optional
    :return: Returns a new file with the original function and the main function added in order to work with the GSL ODE solver.
    :rtype: file
    """
    h0 = options.get('h0', 1e-6)
    atol = options.get('atol', 1e-6)
    rtol = options.get('rtol', 0.0)
    format = options.get('output_format', "csv")
    solver_method = options.get('solver_method', "rkf45")
    t0, t1 = tspan[0], tspan[1]

    shutil.copyfile(odefile, outfile)
    if format == "hdf5":
        f = open(outfile, "r")
        contents = f.readlines()
        f.close()
        contents.insert(4, "#include \"hdf5.h\"\n#define FILENAME \"dset.h5\"\n\n")
        f = open(outfile, "w")
        contents = "".join(contents)
        f.write(contents)
        f.close()
    else:
        pass

    f = open(outfile, 'a')
    f.write('\n')
    f.write('int main(void){\n')
    #Falta por introducirse la opcion de agregar parametros
    f.write('    ' + '/*Aqui se colocan los parametros*/ \n')
    f.write('    ' + 'double params = 0; \n')
    #Como por el momento no trabaja con el jacobiano se declara como un puntero NULL
    # pf.write('    ' + 'int *jac=NULL; \n')
    f.write('    ' + 'gsl_odeiv2_system sys = {func, NULL, dim, &params};\n') 
    f.write('    ' + f'gsl_odeiv2_driver *d = gsl_odeiv2_driver_alloc_y_new (&sys, gsl_odeiv2_step_{solver_method}, {str(h0)}, {str(atol)}, {str(rtol)});\n\n')  
    f.write('    ' + 'int i;\n')
    f.write('    ' + f'double t = {str(t0)}, t1 = {str(t1)};\n')
    f.write('    ' + 'double y0[] = { '+str(y0[0]))
    for i in y0[1:]:
        f.write(', ' + str(i))
    f.write(' };\n\n')  

    if format == "hdf5":
        if str(symbexprs) == "default":  
            f.write('    ' + 'hid_t       file_id, dataset_id, dataspace_id;\n')
            f.write('    ' + 'hsize_t     dims[2];\n')
            f.write('    ' + 'herr_t      status;\n')
            f.write('    ' + 'file_id = H5Fcreate(FILENAME, H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT);\n')
            f.write('    ' + f'dims[0] = {str(step)};\n')
            f.write('    ' + 'dims[1] = dim;\n')
            f.write('    ' + 'dataspace_id = H5Screate_simple(2, dims, NULL);\n')
            f.write('    ' + 'dataset_id = H5Dcreate2(file_id, "/dset", H5T_NATIVE_DOUBLE, dataspace_id, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);\n\n')

            f.write('    ' + 'int j, k;\n')
            f.write('    ' + f'double wdata[{str(step)}][dim];\n')
            f.write('    ' + 'for (k = 0; k < dim; k++){\n')
            f.write('    ' + '    ' + 'wdata[0][k] = y0[k];\n')
            f.write('    ' + '}\n')

            f.write('    ' + f'double dt = t1 / {str(step)};\n')
            f.write('    ' + f'for (i = 1; i < {str(step)}; i++)'+'{\n')
            f.write('    ' + '    ' + 'double ti = t + dt;\n')
            f.write('    ' + '    ' + 'int status = gsl_odeiv2_driver_apply (d, &t, ti, y0);\n')
            f.write('    ' + '    ' + 'if (status != GSL_SUCCESS){\n')
            f.write('    ' + '    ' + '    ' + 'printf ("error, return value=%d\\n", status);\n')
            f.write('    ' + '    ' + '    ' + 'break;\n')
            f.write('    ' + '    ' + '}\n')
            
            f.write('    ' + '    ' + 'for (j = 0; j < dim; j++){\n')
            f.write('    ' + '    ' + '    ' + 'wdata[i][j] = y0[j];\n')
            f.write('    ' + '    ' + '}\n')
        else:
            q7 = len(symbexprs)
            f.write('    ' + 'hid_t       file_id, dataset_id, dataspace_id;\n')
            f.write('    ' + 'hsize_t     dims[2];\n')
            f.write('    ' + 'herr_t      status;\n')
            f.write('    ' + 'file_id = H5Fcreate(FILENAME, H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT);\n')
            f.write('    ' + f'dims[0] = {str(step)};\n')
            f.write('    ' + f'dims[1] = {str(q7)};\n')
            f.write('    ' + 'dataspace_id = H5Screate_simple(2, dims, NULL);\n')
            f.write('    ' + 'dataset_id = H5Dcreate2(file_id, "/dset", H5T_NATIVE_DOUBLE, dataspace_id, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);\n\n')

            symbexprs2 = []
            for i in symbexprs:
                expr_str = str(i)
                expr_str = regex.sub(r'y(\d+)', r'y0[\1]', expr_str)
                symbexprs2.append(expr_str)
            # print(symbexprs)
            # print(symbexprs2)
            
            f.write('    ' + 'double complex symbexprs2[] = { '+str(symbexprs2[0]))
            for i in symbexprs2[1:]:
                f.write(', ' + str(i))
            f.write('};\n\n')

            ab = len(symbexprs2) 
            f.write('    ' + 'int j, k;\n')
            f.write('    ' + f'double wdata[{str(step)}][{str(ab)}];\n')
            f.write('    ' + f'for (k = 0; k < {str(ab)}; k++)'+'{\n')
            f.write('    ' + '    ' + 'wdata[0][k] = creal(symbexprs2[k]);\n')
            f.write('    ' + '}\n\n')
        
            f.write('    ' + f'double dt = t1 / {str(step)};\n')
            f.write('    ' + f'for (i = 1; i < {str(step)}; i++)'+'{\n')
            f.write('    ' + '    ' + 'double ti = t + dt;\n')
            f.write('    ' + '    ' + 'int status = gsl_odeiv2_driver_apply (d, &t, ti, y0);\n')
            f.write('    ' + '    ' + 'if (status != GSL_SUCCESS){\n')
            f.write('    ' + '    ' + '    ' + 'printf ("error, return value=%d\\n", status);\n')
            f.write('    ' + '    ' + '    ' + 'break;\n')
            f.write('    ' + '    ' + '}\n') 

            f.write('    ' + '    ' + 'double complex symbexprs2[] = { '+str(symbexprs2[0]))
            for i in symbexprs2[1:]:
                f.write(', ' + str(i))
            f.write('};\n\n')

            f.write('    ' + '    ' + f'int n = {str(ab)};\n\n')
            f.write('    ' + '    ' + 'for (j = 0; j< n; j++){\n')
            f.write('    ' + '    ' + '    ' + 'wdata[i][j] = creal(symbexprs2[j]);\n')
            f.write('    ' + '    ' + '}\n')     
        f.write('    ' + '}\n')
        f.write('    ' + 'status = H5Dwrite(dataset_id, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, wdata);\n')
        f.write('    ' + 'status = H5Dclose(dataset_id);\n')
        f.write('    ' + 'status = H5Sclose(dataspace_id);\n')
        f.write('    ' + 'status = H5Fclose(file_id);\n')
        f.write('    ' + 'gsl_odeiv2_driver_free (d);\n')
        f.write('    ' + 'return 0;\n')
        f.write('}\n')
        f.close()
    elif format == "csv":
        f.write('    ' + 'FILE *fp;\n')
        f.write('    ' + 'int n;\n')
        f.write('    ' + 'fp = fopen("sol.txt", "a");\n')
        f.write('    ' + 'fprintf (fp, "%.5e", y0[0]);\n')
        f.write('    ' + 'for (n=1 ; n<dim ; n++){\n')
        f.write('    ' + '    ' + 'fprintf (fp, ", %.5e", y0[n]);\n')
        f.write('    ' + '}\n')
        f.write('    ' + 'fclose(fp);\n')
        f.write('    ' + f'double dt = t1 / {str(step)};\n')
        f.write('    ' + f'for (i = 1; i < {str(step)}; i++)'+'{\n')
        f.write('    ' + '    ' + 'double ti = t + dt;\n')
        f.write('    ' + '    ' + 'int status = gsl_odeiv2_driver_apply (d, &t, ti, y0);\n\n')
        f.write('    ' + '    ' + 'if (status != GSL_SUCCESS){\n')
        f.write('    ' + '    ' + '    ' + 'printf ("error, return value=%d\\n", status);\n')
        f.write('    ' + '    ' + '    ' + 'break;\n')
        f.write('    ' + '    ' + '}\n\n')
        f.write('    ' + '    ' + 'fp = fopen("sol.txt", "a");\n')
        f.write('    ' + '    ' + 'int n;\n')
        f.write('    ' + '    ' + 'fprintf (fp, "\\n");\n')
        f.write('    ' + '    ' + 'fprintf (fp, "%.5e", y0[0]);\n')
        f.write('    ' + '    ' + 'for (n=1 ; n<dim ; n++){\n')
        f.write('    ' + '    ' + '    ' + 'fprintf (fp, ", %.5e", y0[n]);\n')
        f.write('    ' + '    ' + '}\n')
        f.write('    ' + '    ' + 'fclose(fp);\n')
        f.write('    ' + '}\n')
        f.write('    ' + 'gsl_odeiv2_driver_free (d);\n')
        f.write('    ' + 'return 0;\n')
        f.write('}\n') 
        f.close()